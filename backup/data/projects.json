[{
	"_id": {
		"$oid": "5a4ae7716df7580f87f4a2c6"
	},
	"course": "",
	"github": "https://github.com/johnsonj561/Project-Portfolio",
	"description": "First single page application with Angular 5 and TypeScript. Simple design allows admin to upload projects and coursework to be viewed by users. Users are able to filter/sort/search/view the projects.",
	"tags": "SPA, Angular, Node.js, Express, MongoDB, TypeScript, AWS",
	"date": "1/1/2018",
	"name": "Project Portfolio",
	"implementation": [
		"Project scaffolding generated by angular-cli",
		"Admin sessions tracked with JSON Web Tokens",
		"Express server and API running on Node.js",
		"MongoDB data storage",
		"Running on Amazon AWS EC2"
	],
	"__v": 0
},
{
	"_id": {
		"$oid": "5a4aea126df7580f87f4a2c7"
	},
	"course": "Information Retrieval",
	"github": "https://github.com/johnsonj561/K-Means-Document-Summarization",
	"description": "A 10 sentence summary was generated from an original document containing 850 sentences with machine learning techniques. Once pre-processed, Python's Natural Language Toolkit (NLTK) was used to cluster the document into 10 groups with the K Means Algorithm. From each of the 10 clusters, the centroid was identified and extracted through use of cosine similarity measurements. Finally, the 10 resulting sentences were combined to produce a 10 sentence document summary.",
	"tags": "Machine Learning, K Means, Clustering, Python, NLTK, Cosine Similarity",
	"date": "12/1/2017",
	"name": "K Means Document Summarization",
	"implementation": [
		"Tokenize, stem, stop word each sentence",
		"Cluster sentences into 10 groups using K Means clustering by NLTK",
		"Calculate the cosine similarity matrix for all sentence pairs in a given cluster, yielding 10 matrices, 1 per cluster",
		"For each Cosine Similarity matrix, Sum scores of each row to determine which row (sentence) has highest similarity with the most documents",
		"Return the sentence from each cluster that has highest similarity with other sentences of the cluster (returned by step 5)",
		" Combine all 10 resulting high similarity sentences into 1 paragraph, which is to become the summary",
		"Sort the summary's sentences in the order that they appear in the original document, to maintain positional relationships of original document",
		"Return summary"
	],
	"__v": 1
},
{
	"_id": {
		"$oid": "5a62b771e95d600547f6d3f2"
	},
	"course": "Natural Language Processing",
	"github": "https://github.com/johnsonj561/Levenshtein-Distance",
	"description": "The Levensthein distance between 2 strings is the sum of operations required to transform s1 into s2. It is commonly referred to as the edit distance between two strings. Operations include: insert, delete, substitute. This implementation scores each operation equally, as 1 point. Some algorithms may choose to weight substitution as 2 points, as it technically includes a delete followed by an insert.\n\nThe edit distance calculation was implemented with Dynamic Programming to achieve quadratic time complexity. Dynamic programming is the process of breaking a complex problem up into sub-problems, solving the sub-problems, and then combining the solutions of the sub-problems to achieve optimal solution. A matrix can often be used to store/recall solutions of sub-problems already completed.",
	"tags": "JavaScript, Natural Language Processing, Edit Distance",
	"date": "1/19/2018",
	"name": "Levenshtein Distance",
	"implementation": [
		"Dynamic programming methodology",
		"Quadratic time and space complexity"
	],
	"__v": 0
},
{
	"_id": {
		"$oid": "5a62c873e95d600547f6d402"
	},
	"github": "https://github.com/johnsonj561/AngularJS-Publishing-Service",
	"description": "A simple implementation of the Publish/Subscribe pattern for AngularJS. This pattern is also referred to as Observer pattern. This service can be used as an alternative to AngularJS $broadcast/$emit/$on methods.",
	"tags": "AngularJS, JavaScript, Design Pattern",
	"date": "1/10/2018",
	"name": "AngularJS Publish/Subscribe",
	"implementation": [
		"Publishing Service implements subscribe and notify methods",
		"Components subscribe to the publishing service, passing a channel key to listen on and a callback function",
		"Components call the Publishing Service's notify method with a channel key",
		"Publishing Service then fires all callback functions registered to the notify channel"
	],
	"__v": 0
},
{
	"_id": {
		"$oid": "5a62ccd1e95d600547f6d404"
	},
	"course": "Information Retrieval",
	"github": "https://github.com/johnsonj561/Search-and-Classification-With-Natural",
	"description": "A final project for Information Retrieval that consists of Natural Language tool selection, research, and demo. As a JavaScript developer, I selected NPM package 'Natural' to implement search and text classification as a REST API. Natural's text pre-processing, TF-IDF calculation, and model serialization were utilized to build an index of web pages. The front facing application, implemented in AngularJS, allowed users to post URL's which would then be indexed on the backend. When user's post search queries, indexed documents are ranked using Cosine Similarity scoring. \n\nNatural's Naive Bayes classification model was trained on the 4 Universities Dataset and stored as JSON. User's are able to post a URL to the server for classification. The classifier then assigns a class of Student, Faculty, Project, or Course to the URL. Naive Bayes is a probabilistic machine learning method that outputs the most likely class, based off the evidence observed during training.",
	"tags": "JavaScript, Search, Classification, AngularJS, Node.js, Express, Natural, Natural Language Processing, Machine Learning",
	"date": "12/1/2017",
	"name": "Search \u0026 Classification API",
	"implementation": [
		"Natural - natural language facility for Node.js, used for tokenization, stemming, and TF-IDF calculations",
		"Node.js Express server with RESP API",
		"Document term tf-idf matrices",
		"Query document cosine similarity",
		"AngularJS single page application"
	],
	"__v": 0
},
{
	"_id": {
		"$oid": "5a62ce04e95d600547f6d405"
	},
	"course": "Information Retrieval",
	"github": "https://github.com/johnsonj561/Weka-Text-Classification",
	"description": "The Naïve Bayes and SVM classifiers were trained and tested with Weka using the provided data set containing both training and test data. Both models were tested using the document-word matrix generated by Weka's default StringToWordVector and the document-word matrix generated through custom StringToWordVector settings. The custom settings included a tf-idf transform and normalization. \n\nThe Support Vector Machine classifier out-performed the Naïve Bayes classifier, achieving an approximate 10% increase in test data classification accuracy.\n\nFull report available at Github URL.",
	"tags": "Machine Learning, Naive Bayes, SVM, Classification, WEKA",
	"date": "11/15/2017",
	"name": "WEKA Text Classification",
	"implementation": [
		"WEKA",
		"Naive Bayes",
		"Support Vector Machine"
	],
	"__v": 0
},
{
	"_id": {
		"$oid": "5a63cb487411c50877de9552"
	},
	"course": "Theory and Philosophy of Computation",
	"github": "https://github.com/johnsonj561/Modular-Exponentiation-Performance",
	"description": "Modular exponentiation is a type of exponentiation performed over a modulus, commonly used in field of cryptography. Calculates the remainder when an integer b (base) raised to the eth power (exponent) is divided by a positive integer m (the modulus):\n\nmodExp = (b^e) % m\n\nDepending on size of int, b^e will overflow relatively quickly\n\nIn Python, integers have arbitrary precision, allowing us to represent an arbitrarily large range of integers that is only limited by available memory. In other languages, like C or C++, overflow requires more attention.\n\nWe can avoid potential overflow and improve memory efficiency through use of following equivalency: if c = a * b then c mod m = (a * b) mod m = [(a mod m) * (b mod m)] mod m\n\n3 modular exponentiation algorithms are described and implemented on github.",
	"tags": "Python, Complexity, Performance",
	"date": "10/08/2017",
	"name": "Modular Exponentiation Performance",
	"implementation": [
		"Implemented with Python",
		"Recursion used to improve performance"
	],
	"__v": 0
},
{
	"_id": {
		"$oid": "5a63ccde7411c50877de9553"
	},
	"course": "Information Retrieval",
	"github": "https://github.com/johnsonj561/IR-Boolean-Search",
	"description": "A simple boolean search application that indexes documents as an inverted index with term frequencies. All text pre-processing, indexing, and search algorithms were implemented as JavaScript modules, no 3rd party libraries were used in the information retrieval process.",
	"tags": "JavaScript, Information Retrieval, Natural Language Processing",
	"date": "9/28/2017",
	"name": "Boolean Search in JavaScript",
	"implementation": [
		"Documents are read from collection directory",
		"Minimal text pre-processing is applied to each document (lowercase, remove whitespace, remove punctuation)",
		"Documents are tokenized, constructing a term list for each document (term, frequency)",
		"Inverted index is created such that inverted index includes list of all terms found in collection",
		"Each term in index points to a postings list, a list of documents that contain the term and the frequency of the term in given document",
		"Application enters prompt loop, requesting search term from user and providing results until terminates"
	],
	"__v": 0
},
{
	"_id": {
		"$oid": "5a63e5167411c50877de9554"
	},
	"course": "Information Retrieval",
	"github": "https://github.com/johnsonj561/IR-Python-Cosine-Similarity",
	"description": "A python application that reads a collection of documents, applies text pre-processing and cleaning, then calculates all document vs document similarity scores using cosine similarity. There is a full project report, CAP6776-Assignment1-jjohn273.pdf, that can be found on github.",
	"tags": "Python, Scikit-learn, Natural Language Processing, Cosine Similarity",
	"date": "9/28/2017",
	"name": "Cosine Similarty in Python",
	"implementation": [
		"Read collection of text documents, tokenize, remove stop words, and apply Porter Stemming",
		"Calculate document frequency and inverse document frequency",
		"Construct a term - document tf-idf matrix",
		"Calculate cosine similarity for each pair of documents, output results as matrix",
		"Utilize Scikit-learn's cosine similarity function to validate results from previous step"
	],
	"__v": 0
},
{
	"_id": {
		"$oid": "5a63e8637411c50877de9555"
	},
	"github": "https://github.com/johnsonj561/KB-Software-Solutions",
	"description": "Website development business owned and operated between 2015 - 2017. The business provided a means for obtaining web dev experience and additional funding for college. Responsive websites were provided to over a dozen small businesses.",
	"tags": "HTML, CSS, JavaScript, jQuery, PHP, MySQL, Bootstrap",
	"date": "7/01/2015",
	"name": "KB Software Solutions",
	"implementation": [
		"LAMP stack hosted with GoDaddy",
		"Custom websites built with Bootstrap",
		"Wordpress web sites and blogs",
		"Google analytics",
		"SEO best practices"
	],
	"__v": 0
},
{
	"_id": {
		"$oid": "5a63ea027411c50877de9556"
	},
	"github": "https://github.com/johnsonj561/My-Training-Page",
	"description": "Web application that allows employers to rapidly train their employees in the cloud. Implemented with MEAN Stack on AWS. Admin users are able to Edit employee profiles and permissions, generate custom training modules, assign training modules to employees, and view employee/training module reports. User use cases include: Register account, edit profile, wiew training modules assigned by admin, complete training modules assigned by admin, view training reports and stats. The project readme.md found on github includes a use case diagram and design mockup.",
	"tags": "AngularJS, JavaScript, Node.js, Express, MongoDB, SPA, JWT, AWS",
	"date": "5/15/2017",
	"name": "My Training Page",
	"implementation": [
		"AngularJS front end single page application",
		"Node.js Express back end and REST API",
		"User authentication with JSON Web Tokens",
		"MongoDB and mongoose used for storage"
	],
	"__v": 0,
	"course": "Semantic Web Applications"
},
{
	"_id": {
		"$oid": "5a63ec677411c50877de9557"
	},
	"course": "Intro Artificial Intelligence",
	"github": "https://github.com/johnsonj561/Cat-Dog-Classification",
	"description": "A pre-trained convolutional neural net, AlexNet, is used to extract features from the data set. Beginning with 100 observations from the Kaggle data set, and increasing to 1000 observations, Discriminant Analysis and the Support Vector Machine are used to generate models using the features that were extracted from the AlexNet CNN. Additionally, image pre-processing filters are applied to detect changes in overall accuracy. ",
	"tags": "Matlab, Machine Learning, Image Processing, SVM, Neural Network, Kagle",
	"date": "3/05/2017",
	"name": "Image Classifier with Matlab",
	"implementation": [
		"Image pre-processing",
		"Feature extraction with convolutional neural network, AlexNet",
		"Prediction models generated with discriminant analysis, cross validation accuracy of 92% achieved "
	],
	"__v": 0
},
{
	"_id": {
		"$oid": "5a63eee17411c50877de9558"
	},
	"course": "Senior Engineering Design",
	"github": "https://github.com/johnsonj561/ED1-Mini-Project/tree/master/ed-mini-project-v4",
	"description": "A system was designed to separate red, green, and blue cubes as they travelled along a conveyor belt. The conveyor belt was constructed with 3D printed parts, DC motors, and an Arduino controller. The belt included a tunnel that colored cubes would travel through, and at the end of the tunnel was a swing arm capable of pushing items off the belt, to the left or the right. A flashing LED and photo-resistor was used to detect items in the tunnel. Once an object was detected - reg, green, and blue LEDs were flashed while simultaneously recording photo-resistor responses. The Arduino could calculate the color of the cube by analyzing photo-resistor values, because the amount of light reflected off the cube would depend on the color of the light. Once the color was confirmed, the conveyor belt would start again, carrying the cube to the end of the tunnel. At this time, the swing arm would push the cube into the left/right bins, or allow the cube to fall straight into the center bin. ",
	"tags": "Arduino, C++, Embedded System, 3D Printing",
	"date": "6/05/2016",
	"name": "Color Sorting System",
	"implementation": [
		"Arduino"
	],
	"__v": 0
},
{
	"_id": {
		"$oid": "5a653e76ddc3f410082d9d62"
	},
	"course": "Senior Engineering Design",
	"github": "https://github.com/johnsonj561/PNP-UI",
	"description": "The PIC n Place machine was designed and built by Sam Rosenfield (electrical), Stephen Lyons (mechanical), and Justin Johnson (programmer) in Fall of 2016 as a Senior design project. The machine utilizes a vacuum nozzle to pick up surface mount components, move them about the workspace, and place them accurately onto printed circuit boards. This is accomplished with 4 degrees of movement - X, Y, Z, and rotation. Computer vision libraries are used to increase accuracy and improve performance. All aspects of the machine were implemented from the ground up with completely custom PCB Design and Software.\n\nMy responsibility included implementation of PC User Interface (Java), and the Computer Vision Error Detection system (Python/OpenCV):",
	"tags": "Java, Python, Computer Vision, OpenCV",
	"date": "11/01/2016",
	"name": "Pick \u0026 Place Machine",
	"implementation": [
		"Connecting to machine's embedded controller over USB",
		"Serial communication to send G-Code instructions to machine and parse machine feedback",
		"Manually controlling machine axes with UI Jog Controls",
		"Parsing PCB Design input files to generate G-Code commands capable of automating part placement",
		"Defining SMT part reels and locations on workspace to allow for full placement automation",
		"Processing batch jobs of G-Code while providing user feedback through interface and log files",
		"Utilizing OpenCV Computer Vision library to detect proper alignment of larger components before being placed",
		"PC User Interface implemented with Java",
		"Computer Vision Error Detection implemented in Python with OpenCV computer vision library"
	],
	"__v": 0
},
{
	"_id": {
		"$oid": "5a65439eddc3f410082d9d63"
	},
	"course": "Intro Embedded Systems",
	"github": "https://github.com/johnsonj561/Android-Bluetooth-V2",
	"description": "The Bluetooth Smart Feeder was created in 2015 for a FAU Embedded System's course project. The feeder, powered by the MSP430 micro-controller, contains various sensors that detect available food supplies and dispense food to the bowl to be eaten. The feeder uses a pressure sensor to determine how much food is present in the bowl. This information is then communicated to the user's mobile phone over bluetooth. The system also includes object recognition that will prevent the dispensing of food when an animal is eating, preventing the system from potentially harming a pet. The mobile phone application allows users to view the feeder's available food supply and dispense additional food by activating the system's motor. The mobile phone application was written in Java using the Android SDK.",
	"tags": "Android, Java, Android SDK, Bluetooth, MSP430",
	"date": "11/15/2015",
	"name": "Bluetooth Smart Feeder",
	"implementation": [
		"MSP430 Project - https://github.com/johnsonj561/MSP430-Bluetooth-Smart-Feeder",
		"Android Application - https://github.com/johnsonj561/Android-Bluetooth-V2"
	],
	"__v": 1
},
{
	"_id": {
		"$oid": "5a654520ddc3f410082d9d64"
	},
	"course": "Intro Internet Computing",
	"github": "https://github.com/johnsonj561/Meals-On-Wheels",
	"description": "The Meals On Wheels Delivery \u0026amp; Routing Services is a web application developed on the LAMP stack. The application provides functionality for both Meals On Wheels employees and their drivers - allowing drivers to create delivery schedules, generate optimal delivery routes using Google Map API, and launch navigation services that will take the driver to their stops.",
	"tags": "HTML, CSS, JavaScript, PHP, MySQL",
	"date": "10/01/2014",
	"name": "Route Scheduling Web App",
	"implementation": [
		""
	],
	"__v": 0
},
{
	"_id": {
		"$oid": "5a654669ddc3f410082d9d65"
	},
	"github": "https://github.com/johnsonj561/Celeb-Selfies",
	"description": "An Android application that allows users to take photos, then apply signatures or draw pictures on top of the image. Once complete, images can be saved to the device or shared with others.",
	"tags": "Android, Java, Android SDK",
	"date": "6/13/2015",
	"name": "Photo Signature Android App",
	"implementation": [
		""
	],
	"__v": 0
}]

